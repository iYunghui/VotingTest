"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.reconnecting = exports.connected = exports.UUID = exports.push = exports.deregister = exports.register = void 0;

var _context = _interopRequireDefault(require("./context.js"));

var _uuid = _interopRequireDefault(require("./uuid.js"));

var _mqtt = _interopRequireDefault(require("mqtt"));

var _superagent = _interopRequireDefault(require("superagent"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var ctx;
var _first_publish = false;
var _is_reconnect = false;

var publish = function publish(channel, message, retained, qos) {
  if (!ctx.mqtt_client) {
    throw 'unable to publish without ctx.mqtt_client';
  }

  if (retained === undefined) retained = false;
  if (qos === undefined) qos = 2;
  ctx.mqtt_client.publish(channel, message, {
    retain: retained,
    qos: qos
  });
};

var subscribe = function subscribe(channel, callback, qos) {
  if (!ctx.mqtt_client) return;
  if (qos === undefined) qos = 2;
  return ctx.mqtt_client.subscribe(channel, {
    qos: qos
  }, callback);
};

var unsubscribe = function unsubscribe(channel) {
  if (!ctx.mqtt_client) return;
  return ctx.mqtt_client.unsubscribe(channel);
};

var on_connect = function on_connect() {
  if (!_is_reconnect) {
    console.log('Successfully connect to %s', ctx.url);
    console.log('Device ID: %s.', ctx.app_id);
    console.log('Device name: %s.', ctx.name);
    subscribe(ctx.o_chans['ctrl'], function (err, granted) {
      if (err) {
        throw 'Subscribe to control channel failed';
      }
    });
  } else {
    console.info('Reconnect: %s.', ctx.name);
    publish(ctx.i_chans['ctrl'], JSON.stringify({
      'state': 'offline',
      'rev': ctx.rev
    }), true // retained message
    );
  }

  ctx.i_chans.remove_all_df();
  ctx.o_chans.remove_all_df();
  ctx.mqtt_client.publish(ctx.i_chans['ctrl'], JSON.stringify({
    'state': 'online',
    'rev': ctx.rev
  }), {
    retain: true,
    qos: 2
  }, function (err) {
    if (!err) {
      _first_publish = true;
    }
  });
  _is_reconnect = true;

  if (ctx.on_connect) {
    ctx.on_connect();
  }
};

var on_message = function on_message(topic, message) {
  if (topic == ctx.o_chans['ctrl']) {
    var signal = JSON.parse(message);
    var handling_result = null;

    switch (signal['command']) {
      case 'CONNECT':
        if ('idf' in signal) {
          var idf = signal['idf'];
          ctx.i_chans.add(idf, signal['topic']);
          handling_result = ctx.on_signal(signal['command'], [idf]);
        } else if ('odf' in signal) {
          var odf = signal['odf'];
          ctx.o_chans.add(odf, signal['topic']);
          handling_result = ctx.on_signal(signal['command'], [odf]);
          subscribe(ctx.o_chans.topic(odf));
        }

        break;

      case 'DISCONNECT':
        if ('idf' in signal) {
          var _idf = signal['idf'];
          ctx.i_chans.remove_df(_idf);
          handling_result = ctx.on_signal(signal['command'], [_idf]);
        } else if ('odf' in signal) {
          var _odf = signal['odf'];
          unsubscribe(ctx.o_chans.topic(_odf));
          ctx.o_chans.remove_df(_odf);
          handling_result = ctx.on_signal(signal['command'], [_odf]);
        }

        break;
    }

    var res_message = {
      'msg_id': signal['msg_id']
    };

    if (typeof handling_result == 'boolean' && handling_result) {
      res_message['state'] = 'ok';
    } else {
      res_message['state'] = 'error';
      res_message['reason'] = handling_result[1];
    }

    publish(ctx.i_chans['ctrl'], JSON.stringify(res_message));
    return;
  } else {
    var _odf2 = ctx.o_chans.df(topic);

    if (!_odf2) return;
    ctx.on_data(_odf2, JSON.parse(message));
  }
};

var on_disconnect = function on_disconnect() {
  console.info('%s (%s) disconnected from  %s.', ctx.name, ctx.app_id, ctx.url);

  if (ctx.on_disconnect) {
    ctx.on_disconnect();
  }
};

var register = function register(url, params, callback) {
  ctx = new _context.default();

  if (ctx.mqtt_client) {
    throw 'Already registered';
  }

  ctx.url = url;

  if (url == null || url == '') {
    throw 'Invalid url: %s', ctx.url;
  }

  ctx.app_id = params['id'] ? params['id'] : (0, _uuid.default)();
  var body = {
    'name': params['name'],
    'idf_list': params['idf_list'],
    'odf_list': params['odf_list'],
    'accept_protos': params['accept_protos'] ? params['accept_protos'] : 'mqtt',
    'profile': params['profile']
  };
  var _reg_msg = 'register_callback is deprecated, please use `on_register` instead.';

  if (typeof params['on_register'] != 'undefined' && typeof params['register_callback'] != 'undefined') {
    throw _reg_msg;
  } else if (typeof params['on_register'] != 'undefined') {
    ctx.on_register = params['on_register'];
  } else if (typeof params['register_callback'] != 'undefined') {
    console.warning(_reg_msg);
    ctx.on_register = params['register_callback'];
  } // other callbacks


  ctx.on_deregister = params['on_deregister'];
  ctx.on_connect = params['on_connect'];
  ctx.on_disconnect = params['on_disconnect']; // filter out the empty `df_list`, in case of empty list, server reponsed 403.

  ['idf_list', 'odf_list'].forEach(function (x) {
    if (Array.isArray(body[x]) && body[x].length == 0) delete body[x];
  });
  new Promise(function (resolve, reject) {
    _superagent.default.put(ctx.url + '/' + ctx.app_id).type('json').accept('json').send(body).then(function (res) {
      resolve(res);
    }, function (err) {
      reject(err);
    });
  }).then(function (res) {
    var metadata = res.body;

    if (typeof metadata === 'string') {
      metadata = JSON.parse(metadata);
    }

    ctx.name = metadata['name'];
    ctx.mqtt_host = metadata['url']['host'];
    ctx.mqtt_port = metadata['url']['ws_port'];
    ctx.mqtt_username = metadata['username'] ? metadata['username'] : '';
    ctx.mqtt_password = metadata['password'] ? metadata['password'] : '';
    ctx.i_chans['ctrl'] = metadata['ctrl_chans'][0];
    ctx.o_chans['ctrl'] = metadata['ctrl_chans'][1];
    ctx.rev = metadata['rev'];
    ctx.mqtt_client = _mqtt.default.connect(metadata.url['ws_scheme'] + '://' + ctx.mqtt_host + ':' + ctx.mqtt_port, {
      clientId: 'iottalk-js-' + ctx.app_id,
      username: ctx.mqtt_username,
      password: ctx.mqtt_password,
      will: {
        topic: ctx.i_chans['ctrl'],
        // in most case of js DA, it never connect back
        payload: JSON.stringify({
          'state': 'offline',
          'rev': ctx.rev
        }),
        retain: true
      },
      keepalive: 30 // seems 60 is problematic for default mosquitto setup

    });
    ctx.mqtt_client.on('connect', function (connack) {
      console.info('mqtt_connect');
      on_connect();

      if (callback) {
        callback({
          'metadata': metadata,
          'dan': ctx
        });
      }
    });
    ctx.mqtt_client.on('reconnect', function () {
      console.info('mqtt_reconnect');
    });
    ctx.mqtt_client.on('disconnect', function (packet) {
      console.info('mqtt_disconnect');
      on_disconnect();
    });
    ctx.mqtt_client.on('error', function (error) {
      console.error('mqtt_error', error);
    });
    ctx.mqtt_client.on('message', function (topic, message, packet) {
      on_message(topic, message.toString()); // Convert message from Uint8Array to String
    });
    ctx.on_signal = params['on_signal'];
    ctx.on_data = params['on_data'];
    setTimeout(function () {
      if (!_first_publish) {
        throw 'MQTT connection timeout';
      }
    }, 5000);

    if (ctx.on_register) {
      ctx.on_register();
    }
  }, function (err) {
    console.error('on_failure', err);
    if (callback) callback(false, err);
    return;
  });
};

exports.register = register;

var deregister = function deregister(callback) {
  if (!ctx.mqtt_client) {
    console.error('Not registered');
    if (callback) return callback(true);
    return;
  }

  publish(ctx.i_chans['ctrl'], JSON.stringify({
    'state': 'offline',
    'rev': ctx.rev
  }), true);
  ctx.mqtt_client.end();

  _superagent.default.del(ctx.url + '/' + ctx.app_id).type('json').accept('json').send(JSON.stringify({
    'rev': ctx.rev
  })).then(function (res) {
    ctx.mqtt_client = null;

    if (ctx.on_deregister) {
      ctx.on_deregister();
    }

    if (callback) return callback(true);
  }, function (err) {
    console.error('deregister fail', err);
    if (callback) return callback(false);
  });
};

exports.deregister = deregister;

var push = function push(idf_name, data, qos) {
  if (!ctx.mqtt_client || !_first_publish) {
    console.error('Not registered');
    return;
  }

  if (!ctx.i_chans.topic(idf_name)) {
    return;
  }

  if (qos === undefined) qos = 1;

  if (_typeof(data) != 'object') {
    data = [data];
  }

  publish(ctx.i_chans.topic(idf_name), JSON.stringify(data), false, qos);
};

exports.push = push;

var UUID = function UUID() {
  return ctx.app_id ? ctx.app_id : (0, _uuid.default)();
};

exports.UUID = UUID;

var connected = function connected() {
  if (_typeof(ctx.mqtt_client) !== 'object') return false;
  return ctx.mqtt_client.connected;
};

exports.connected = connected;

var reconnecting = function reconnecting() {
  if (_typeof(ctx.mqtt_client) !== 'object') return false;
  return ctx.mqtt_client.reconnecting;
};

exports.reconnecting = reconnecting;