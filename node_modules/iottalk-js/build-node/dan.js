"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.register = register;
exports.deregister = deregister;
exports.push = push;
exports.Client = void 0;

var _mqtt = _interopRequireDefault(require("mqtt"));

var _superagent = _interopRequireDefault(require("superagent"));

var _context = _interopRequireDefault(require("./context"));

var _uuid = _interopRequireDefault(require("./uuid"));

var _exceptions = require("./exceptions");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var Client = /*#__PURE__*/function () {
  function Client() {
    _classCallCheck(this, Client);

    this.ctx = new _context["default"]();
    this.firstPub = false;
    this.IsReconnect = false;
    this.onConnect = this.onConnect.bind(this);
    this.onDisconnect = this.onDisconnect.bind(this);
  }

  _createClass(Client, [{
    key: "publish",
    value: function publish(channel, message, retain, qos) {
      var _this = this;

      if (!this.ctx.mqttClient) throw new Error('unable to publish without ctx.mqttClient');
      if (retain === undefined) retain = false;
      if (qos === undefined) qos = 2;
      return new Promise(function (resolve, reject) {
        _this.ctx.mqttClient.publish(channel, JSON.stringify(message), {
          retain: retain,
          qos: qos
        }, function (err) {
          if (err) {
            return reject(err);
          }

          return resolve();
        });
      });
    }
  }, {
    key: "subscribe",
    value: function subscribe(channel, qos) {
      var _this2 = this;

      if (!this.ctx.mqttClient) throw new Error('unable to publish without ctx.mqttClient');
      if (qos === undefined) qos = 2;
      return new Promise(function (resolve, reject) {
        _this2.ctx.mqttClient.subscribe(channel, {
          qos: qos
        }, function (err) {
          if (err) {
            return reject(err);
          }

          return resolve();
        });
      });
    }
  }, {
    key: "unsubscribe",
    value: function unsubscribe(channel) {
      var _this3 = this;

      if (!this.ctx.mqttClient) throw new Error('unable to publish without ctx.mqttClient');
      return new Promise(function (resolve, reject) {
        _this3.ctx.mqttClient.unsubscribe(channel, function (err) {
          if (err) {
            return reject(err);
          }

          return resolve();
        });
      });
    }
  }, {
    key: "onConnect",
    value: function onConnect() {
      var _this4 = this;

      console.info('mqtt_connect');
      var pub;

      if (!this.IsReconnect) {
        pub = this.subscribe(this.ctx.OChans.ctrl).then(function () {
          console.log("Successfully connect to ".concat(_this4.ctx.url));
          console.log("Device ID: ".concat(_this4.ctx.appID));
          console.log("Device name: ".concat(_this4.ctx.name, "."));

          if (typeof document !== 'undefined') {
            document.title = _this4.ctx.name;
          }
        })["catch"](function () {
          throw new Error('Subscribe to control channel failed');
        });
      } else {
        console.info("Reconnect: ".concat(this.ctx.name, "."));
        pub = this.publish(this.ctx.IChans.ctrl, {
          state: 'offline',
          rev: this.ctx.rev
        }, true // retained message
        );
      }

      pub.then(function () {
        _this4.ctx.IChans.removeAllDF();

        _this4.ctx.OChans.removeAllDF();

        _this4.publish(_this4.ctx.IChans.ctrl, {
          state: 'online',
          rev: _this4.ctx.rev
        }, true // retained message
        ).then(function () {
          _this4.firstPub = true;
        });

        _this4.IsReconnect = true;

        if (_this4.ctx.onConnect) {
          _this4.ctx.onConnect(_this4);
        }
      })["catch"](function (err) {
        console.error(err);
      });
    }
  }, {
    key: "onMessage",
    value: function onMessage(topic, message) {
      if (topic === this.ctx.OChans.ctrl) {
        var signal = JSON.parse(message);
        var handlingResult = null;

        switch (signal.command) {
          case 'CONNECT':
            if ('idf' in signal) {
              var idf = signal.idf;
              this.ctx.IChans.add(idf, signal.topic);
              handlingResult = this.ctx.onSignal(signal.command, [idf]);
            } else if ('odf' in signal) {
              var odf = signal.odf;
              this.ctx.OChans.add(odf, signal.topic);
              handlingResult = this.ctx.onSignal(signal.command, [odf]);
              this.subscribe(this.ctx.OChans.topic(odf));
            }

            break;

          case 'DISCONNECT':
            if ('idf' in signal) {
              var _idf = signal.idf;
              this.ctx.IChans.removeDF(_idf);
              handlingResult = this.ctx.onSignal(signal.command, [_idf]);
            } else if ('odf' in signal) {
              var _odf = signal.odf;
              this.unsubscribe(this.ctx.OChans.topic(_odf));
              this.ctx.OChans.removeDF(_odf);
              handlingResult = this.ctx.onSignal(signal.command, [_odf]);
            }

            break;

          default:
            throw new Error('unknown signal');
        }

        var resMsg = {
          msg_id: signal.msg_id
        };

        if (typeof handlingResult === 'boolean' && handlingResult) {
          resMsg.state = 'ok';
        } else {
          resMsg.state = 'error';
          var _handlingResult = handlingResult;

          var _handlingResult2 = _slicedToArray(_handlingResult, 2);

          resMsg.reason = _handlingResult2[1];
        }

        this.publish(this.ctx.IChans.ctrl, resMsg);
      } else {
        var _odf2 = this.ctx.OChans.df(topic);

        if (!_odf2) return;
        this.ctx.onData(_odf2, JSON.parse(message));
      }
    }
  }, {
    key: "onDisconnect",
    value: function onDisconnect() {
      console.info("".concat(this.ctx.name, " (").concat(this.ctx.appID, ") disconnected from ").concat(this.ctx.url, "."));

      if (this.ctx.onDisconnect) {
        this.ctx.onDisconnect(this);
      }
    }
  }, {
    key: "register",
    value: function register(params) {
      var _this5 = this;

      if (this.ctx.mqttClient) {
        throw new _exceptions.RegistrationError('Already registered');
      }

      this.ctx.url = params.url;

      if (!this.ctx.url || this.ctx.url === '') {
        throw new _exceptions.RegistrationError("Invalid url: ".concat(this.ctx.url));
      }

      this.ctx.appID = params.id || (0, _uuid["default"])();
      var body = {
        name: params.name,
        idf_list: params.idfList,
        odf_list: params.odfList,
        accept_protos: params.acceptProtos || 'mqtt',
        profile: params.profile
      }; // other callbacks

      this.ctx.onRegister = params.onRegister;
      this.ctx.onDeregister = params.onDeregister;
      this.ctx.onConnect = params.onConnect;
      this.ctx.onDisconnect = params.onDisconnect; // filter out the empty `df_list`, in case of empty list, server reponsed 403.

      ['idf_list', 'odf_list'].forEach(function (x) {
        if (Array.isArray(body[x]) && body[x].length === 0) delete body[x];
      });

      _superagent["default"].put("".concat(this.ctx.url, "/").concat(this.ctx.appID)).type('json').accept('json').send(body).then(function (res) {
        var metadata = res.body;

        if (typeof metadata === 'string') {
          metadata = JSON.parse(metadata);
        }

        _this5.ctx.name = metadata.name;
        _this5.ctx.mqttHost = metadata.url.host;
        _this5.ctx.mqttPort = metadata.url.ws_port;
        _this5.ctx.mqttUsername = metadata.username || '';
        _this5.ctx.mqttPassword = metadata.password || '';

        var _metadata$ctrl_chans = _slicedToArray(metadata.ctrl_chans, 2);

        _this5.ctx.IChans.ctrl = _metadata$ctrl_chans[0];
        _this5.ctx.OChans.ctrl = _metadata$ctrl_chans[1];
        _this5.ctx.rev = metadata.rev;
        _this5.ctx.mqttClient = _mqtt["default"].connect("".concat(metadata.url.ws_scheme, "://").concat(_this5.ctx.mqttHost, ":").concat(_this5.ctx.mqttPort), {
          clientId: "iottalk-js-".concat(_this5.ctx.appID),
          username: _this5.ctx.mqttUsername,
          password: _this5.ctx.mqttPassword,
          will: {
            topic: _this5.ctx.IChans.ctrl,
            // in most case of js DA, it never connect back
            payload: JSON.stringify({
              state: 'offline',
              rev: _this5.ctx.rev
            }),
            retain: true
          },
          keepalive: 30 // seems 60 is problematic for default mosquitto setup

        });

        _this5.ctx.mqttClient.on('connect', _this5.onConnect);

        _this5.ctx.mqttClient.on('reconnect', function () {
          console.info('mqtt_reconnect');
        });

        _this5.ctx.mqttClient.on('disconnect', _this5.onDisconnect);

        _this5.ctx.mqttClient.on('error', function (error) {
          console.error('mqtt_error', error);
        });

        _this5.ctx.mqttClient.on('message', function (topic, message, packet) {
          // Convert message from Uint8Array to String
          _this5.onMessage(topic, message.toString(), packet);
        });

        _this5.ctx.onSignal = params.onSignal;
        _this5.ctx.onData = params.onData;
        setTimeout(function () {
          if (!_this5.firstPub) {
            throw new _exceptions.RegistrationError('MQTT connection timeout');
          }
        }, 5000);

        if (_this5.ctx.onRegister) {
          _this5.ctx.onRegister(_this5);
        }
      })["catch"](function (err) {
        console.error('on_failure', err);
      });
    }
  }, {
    key: "deregister",
    value: function deregister() {
      var _this6 = this;

      if (!this.ctx.mqttClient) {
        throw new _exceptions.RegistrationError('Not registered');
      }

      this.publish(this.ctx.IChans.ctrl, {
        state: 'offline',
        rev: this.ctx.rev
      }, true);
      this.ctx.mqttClient.end();

      _superagent["default"].del("".concat(this.ctx.url, "/").concat(this.ctx.appID)).type('json').accept('json').send(JSON.stringify({
        rev: this.ctx.rev
      })).then(function () {
        _this6.ctx.mqttClient = null;

        if (_this6.ctx.onDeregister) {
          _this6.ctx.onDeregister(_this6);
        }
      }, function (err) {
        console.error('deregister fail', err);
      });
    }
  }, {
    key: "push",
    value: function push(idf, data, qos) {
      if (!this.ctx.mqttClient || !this.firstPub) {
        throw new _exceptions.RegistrationError('Not registered');
      }

      if (!this.ctx.IChans.topic(idf)) {
        return;
      }

      if (qos === undefined) qos = 1;

      if (!Array.isArray(data)) {
        data = [data];
      }

      this.publish(this.ctx.IChans.topic(idf), data, false, qos);
    }
  }]);

  return Client;
}();

exports.Client = Client;
var defaultClient = new Client();

function register() {
  return defaultClient.register.apply(defaultClient, arguments);
}

function deregister() {
  return defaultClient.deregister.apply(defaultClient, arguments);
}

function push() {
  return defaultClient.push.apply(defaultClient, arguments);
}